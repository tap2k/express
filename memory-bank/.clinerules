# Cline Rules: Express CMS

## Project Patterns

### File Organization
#### Frontend (NextJS)
- Components are stored in the `/components` directory
- Hooks are stored in the `/hooks` directory
- Pages are stored in the `/pages` directory
- API routes are stored in the `/pages/api` directory
- Authentication pages are stored in the `/pages/auth` directory
- Static assets are stored in the `/public` directory
  - Media assets in `/public/audio` and `/public/images`
  - Map marker icons in `/public` with naming pattern `marker-icon-[color].png`
- Styles are stored in the `/styles` directory

#### Backend (Strapi)
- Content types are defined in `/src/api/[type]/content-types/[type]/schema.json`
- Controllers are defined in `/src/api/[type]/controllers/[type].js`
- Utility functions are defined in `/config/functions.js`
- Environment variables are stored in `.env`

### Naming Conventions
- Component files use camelCase (e.g., `audioPlayer.js`)
- Hook files use camelCase and describe their function (e.g., `getUser.js`, `updateSubmission.js`)
- API routes use camelCase and describe their function (e.g., `addChannel.js`)
- Related components follow consistent naming patterns:
  - Media players: `[type]player.js` (e.g., `audioplayer.js`, `videoplayer.js`)
  - Media recorders: `[type]recorder.js` (e.g., `audiorecorder.js`, `videorecorder.js`)
  - Specialized variants: `[type]player[variant].js` (e.g., `videoplayerjs.js`, `videoplayer360.js`)

### Component Structure
#### Frontend Components
- Components are implemented as functional components with hooks
- Media components typically include player and recorder variants
- UI components follow a consistent pattern with props destructuring
- Components use memo for performance optimization where appropriate
- Dynamic imports are used for heavy components (especially media-related)
- Specialized components for different media types and presentation formats

#### Backend Components
- Controllers follow a consistent pattern with createCoreController extension
- Custom functions for permission checking and media handling
- Utility functions for common operations like ID generation and validation
- Content types with well-defined relationships and attributes

### Hook Patterns
#### Frontend Hooks
- API interaction hooks follow a consistent pattern:
  - Accept parameters as a single object for flexibility
  - Use axios for HTTP requests
  - Implement consistent error handling with `setError`
  - Return response data or null on error
- Utility hooks provide reusable functionality across components
- State management hooks encapsulate complex state logic
- Media control hooks handle playback state and interactions

#### Backend Patterns
- Permission checking with hierarchical inheritance
- Private ID generation and validation using XOR encryption
- Media file handling with proper cleanup
- Content filtering based on access level

## Implementation Preferences

### Code Style
#### Frontend
- Functional components with hooks for state management
- Async/await for asynchronous operations
- Props destructuring in component parameters
- JSX for component rendering
- Inline styles for component-specific styling
- Dynamic styling based on props and state
- Conditional rendering with ternary operators and logical AND

#### Backend
- Controller extension pattern for custom functionality
- Async/await for database operations
- Object parameter pattern for flexibility
- Consistent error handling and response formatting
- Utility function extraction for common operations

### State Management
#### Frontend
- React hooks (useState, useEffect, useRef) for local state
- Custom hooks for shared state logic
- URL parameters for persistent state across page loads
- Refs for DOM element access and manipulation
- Callback refs for dynamic element references

#### Backend
- Database queries for persistent state
- In-memory processing for temporary operations
- Transaction-based updates for related entities
- Recursive operations for hierarchical data

### API Interaction
#### Frontend to Backend
- Custom hooks for API calls
- Consistent error handling with dedicated error hooks
- FormData for file uploads and multipart requests
- Progress tracking for uploads
- Three access patterns:
  - Public access (channelID)
  - Private access (privateID)
  - Authenticated access (JWT)

#### Backend to External Services
- Axios for HTTP requests
- Asynchronous processing for long-running operations
- Webhook callbacks for completion notifications
- Error handling with appropriate logging

## Development Workflow

### Feature Implementation
1. Understand requirements
2. Identify affected components, hooks, and controllers
3. Implement frontend changes
4. Implement backend changes if needed
5. Test functionality
6. Update documentation

### Testing Strategy
- Manual testing of UI components
- Functional testing of features
- Cross-browser compatibility testing
- Mobile responsiveness testing
- Media format compatibility testing
- Permission and access control testing
- Error handling and recovery testing

### Performance Considerations
#### Frontend
- Use dynamic imports for heavy components
- Implement memoization for expensive renders
- Use refs to avoid unnecessary re-renders
- Optimize media loading and playback
- Consider marker clustering for maps with many points

#### Backend
- Optimize database queries with proper indexing
- Implement pagination for large data sets
- Use efficient algorithms for recursive operations
- Consider caching for frequently accessed data
- Optimize file handling for large media files

### Documentation Updates
- Update memory bank files when implementing significant changes
- Document new patterns and preferences in .clinerules
- Keep activeContext.md and progress.md up to date
- Document complex component interactions and data flows
- Note TODOs and incomplete features

## Project-Specific Knowledge

### Media Handling
- The application supports various media types:
  - Images (JPEG, PNG, GIF, WebP)
  - Videos (MP4, WebM)
  - Audio (MP3, WAV)
  - 360Â° content (equirectangular images and videos with various mappings)
  - External media (YouTube, Vimeo, Google Photos)
- Custom players and recorders are implemented for different media types
- Media type detection uses the mime-types library
- Media files are stored in Strapi's file system with metadata
- Media URLs are constructed using the getMediaURL() hook
- EXIF data extraction for geolocation from images
- Timeline control for custom start/end points in media playback

### Content Organization
- Content is organized into channels ("reels") with hierarchical relationships
- Each channel has a unique ID and a private ID (XOR encrypted) for management
- Channels can have parent-child relationships with permission inheritance
- Content items belong to channels and can have:
  - Media files (primary content)
  - Audio files (optional audio overlay)
  - Metadata (title, description, etc.)
  - Geolocation (lat/long for maps)
  - Tags for categorization
  - Publication status
- Tags are channel-specific and can be combined or purged
- Content is ordered within channels with automatic reordering
- Content can be presented in different formats:
  - Maps (using Leaflet with custom tilesets)
  - Slideshows (with playback controls and interval timing)
  - Tag walls (organized by tags with visual indicators)
  - Grids (for browsing and selection)
  - Board view (for management)

### Authentication
- Three-tier access model:
  - Public access: View-only for public channels (published content only)
  - Private link access: Full management via privateID (XOR encrypted)
  - Authenticated access: Based on user permissions (owner/editor)
- JWT tokens stored in HTTP-only cookies
- Google OAuth integration available
- Authentication state is checked server-side in getServerSideProps
- Permission inheritance from parent channels
- Content filtering based on access level

### External Services
- ChatGPT integration for AI-powered content generation
- DALL-E integration for image generation
- Email sending functionality for notifications and sharing
- External video generation service for creating videos from channel content
- OpenStreetMap geocoding for location-based content
- YouTube API for playlist handling and embedding
- Google Photos API for album content integration

## Known Challenges

### Potential Areas of Complexity
- Timeline control for media playback has complex interaction logic
- Three-tier access model requires careful permission handling
- Permission inheritance with deeply nested channel hierarchies
- Map performance with large numbers of markers
- Media compatibility across different browsers
- Mobile interactions for complex features like drag-and-drop
- Video generation process monitoring and error handling
- Recursive operations for hierarchical data structures

### Common Patterns
- Use of dynamic imports for heavy components
- Consistent error handling through dedicated hooks
- Progress tracking for uploads and processing
- Conditional rendering based on authentication state
- Specialized handling for different media types
- Responsive design with flexible layouts
- XOR encryption for private IDs
- Recursive permission checking

This file will be updated as new patterns, preferences, and project intelligence are discovered during development.
